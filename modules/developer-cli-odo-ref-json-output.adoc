:_content-type: REFERENCE
[id="odo-json-output_{context}"]
= JSON output

`odo` commands that output content generally accept a `-o json` flag to output this content in JSON format, suitable for other programs to parse this output more easily.

When used with the `-o json` flags, a command that completes successully:

  - Terminates with a zero exit status.
  - Returns its result in JSON format in its standard output stream.

A command with the `-o json` flag that completes with an error:

  - Terminates with a non-zero exit status.
  - Returns an error message in its standard error stream, in the unique field `message` of a JSON object, for example, `{ "message": "file not found" }`.

The structures used to return information using JSON output are defined in link:https://github.com/redhat-developer/odo/tree/main/pkg/api[the `pkg/api` package].


== odo analyze -o json

The `odo analyze` command analyzes the files in the current directory, to select the best devfiles to use
from the devfiles in the registries defined in the list of preferred registries with the command `odo preference view`.

The output of this command contains a list of devfile name and registry name:

.Sample command
[source,terminal]
----
$ odo analyze -o json
----

.Sample output on success
[source,json]
----
[
  {
      "devfile": "nodejs",
      "devfileRegistry": "DefaultDevfileRegistry"
  }
]
----

.Command to determine return code
[source,terminal]
----
$ echo $?
----

.Sample success return code
[source,terminal]
----
0
----

If the command is executed in an empty directory, it returns an error in the standard error stream and completes with a non-zero exit status:

.Sample command
[source,terminal]
----
$ odo analyze -o json
----

.Sample output on failure
[source,json]
----
{
  "message": "No valid devfile found for project in /home/user/my/empty/directory"
}
----

.Command to determine return code
[source,terminal]
----
$ echo $?
----

.Sample failure return code
[source,terminal]
----
1
----

== odo init -o json

The `odo init` command downloads a devfile and, optionally, a starter project. The output of this command contains the path of the downloaded devfile and its content, in JSON format.

.Sample command
[source,terminal]
----
$ odo init -o json \
    --name aname \
    --devfile go \
    --starter go-starter
----

.Sample output on success
[source,json]
----
{
  "devfilePath": "/home/user/my-project/devfile.yaml",
  "devfileData": {
    "devfile": {
      "schemaVersion": "2.1.0",
      [...]
    },
    "supportedOdoFeatures": {
      "dev": true,
      "deploy": false,
      "debug": false
    }
  },
  "forwardedPorts": [],
  "runningIn": {
    "dev": false,
    "deploy": false
  },
  "managedBy": "odo"
}
----

.Command to determine return code
[source,terminal]
----
$ echo $?
----
.Sample success return code
[source,terminal]
----
0
----

If the command fails, for example, if you run it a second time after a success, it will return an error in the standard error stream and exit with a non-zero exit status:

.Sample command
[source,terminal]
----
$ odo init -o json \
    --name aname \
    --devfile go \
    --starter go-starter
----

.Sample output on failure
[source,json]
----
{
  "message": "a devfile already exists in the current directory"
}
----

.Command to determine return code
[source,terminal]
----
echo $?
----

.Sample failure return code
[source,terminal]
----
1
----

== odo describe component -o json

The `odo describe component` command returns information about a component, either the component defined by a Devfile in the current directory, or a deployed component given its name and namespace.

When the `odo describe component` command is executed, without any parameters, from a directory containing a Devfile, it will return information about the Devfile including:

- The path of the Devfile.
- The content of the Devfile.
- Supported `odo` features, indicating if the Devfile defines necessary information to run `odo dev`, `odo dev --debug`, and `odo deploy`.

The status of the component is also returned, including:

- The forwarded ports if odo is currently running in Dev mode,
- The modes in which the component is deployed, either `none, Dev, Deploy, or both.

.Sample command
[source,terminal]
----
$ odo describe component -o json
----

.Sample output on success
[source,json]
----
{
  "devfilePath": "/home/phmartin/Documents/tests/tmp/devfile.yaml",
  "devfileData": {
    "devfile": {
      "schemaVersion": "2.0.0",
      [ devfile.yaml file content ]
    },
    "supportedOdoFeatures": {
      "dev": true,
      "deploy": false,
      "debug": true
    }
  },
  "devForwardedPorts": [
    {
      "containerName": "runtime",
      "localAddress": "127.0.0.1",
      "localPort": 40001,
      "containerPort": 3000
    }
  ],
  "runningIn": {
    "dev": true,
    "deploy": false
  },
  "managedBy": "odo"
}
----

When the `odo describe component` commmand is executed with a name and namespace:

- It returns the modes in which the component is deployed (either Dev, Deploy or both)

- It cannot return information about a component that has not been deployed. 

- It will never return information about the Devfile, even if a Devfile is present in the current directory.

- It will never return information about the forwarded ports, as the information resides in the directory of the Devfile.

.Sample command
[source,terminal]
----
$ odo describe component --name aname -o json
----

.Sample output on success
[source,json]
----
{
  "runningIn": {
    "dev": true,
    "deploy": false
  },
  "managedBy": "odo"
}
----

== odo list -o json

The `odo list` command returns information about components running on a specific namespace, and components defined in the local Devfile, if any.

`components`:: Lists the components either deployed in the cluster, or defined in the local Devfile.

`componentInDevfile`:: The name of the component present in the `components` list that is defined in the local Devfile, or empty if no local Devfile is present.

In this example, the `component2` component is running in Deploy mode, and the command is executed from a directory containing a Devfile defining a `component1` component, not running.

.Sample command
[source,terminal]
----
$ odo list --namespace project1
----

.Sample output
[source,json]
----
{
  "componentInDevfile": "component1",
  "components": [
    {
      "name": "component2",
      "managedBy": "odo",
      "runningIn": {
        "dev": false,
        "deploy": true
      },
      "projectType": "nodejs"
    },
    {
      "name": "component1",
      "managedBy": "",
      "runningIn": {
        "dev": false,
        "deploy": false
      },
      "projectType": "nodejs"
    }
  ]
}
----

## odo registry -o json

The `odo registry` command lists all the Devfile stacks from Devfile registries.

The default output returns information found in the registry index for stacks:

.Sample command
[source,terminal]
----
$ odo registry -o json
----

.Sample output
[source,json]
----
[
  {
    "name": "python-django",
    "displayName": "Django",
    "description": "Python3.7 with Django",
    "registry": {
      "name": "DefaultDevfileRegistry",
      "url": "https://registry.devfile.io",
      "secure": false
    },
    "language": "python",
    "tags": [
      "Python",
      "pip",
      "Django"
    ],
    "projectType": "django",
    "version": "1.0.0",
    "starterProjects": [
      "django-example"
    ]
  }, [...]
]
----

Using the `--details` flag, adds information about the Devfile:

.Sample command
[source,terminal]
----
$ odo registry --details -o json
----

.Sample output
[source,json]
----
[
  {
    "name": "python-django",
    "displayName": "Django",
    "description": "Python3.7 with Django",
    "registry": {
      "name": "DefaultDevfileRegistry",
      "url": "https://registry.devfile.io",
      "secure": false
    },
    "language": "python",
    "tags": [
      "Python",
      "pip",
      "Django"
    ],
    "projectType": "django",
    "version": "1.0.0",
    "starterProjects": [
      "django-example"
    ],
    "devfileData": {
      "devfile": {
        "schemaVersion": "2.0.0",
        [ devfile.yaml file content ]
      },
      "supportedOdoFeatures": {
        "dev": true,
        "deploy": false,
        "debug": true
      }
    },
  }, [...]
]
----

== odo list binding -o json

The `odo list binding` command lists all service binding resources deployed in the current namespace,
and all service binding resources declared in the Devfile, if executed from a component directory.

The names of the ServiceBinding resources declared in the current Devfile are listed in the `bindingsInDevfile`
field of the output.

If a Service Binding resource is found in the current namespace, it also displays the variables that can be used from
the component in the `status.bindingFiles` or `status.bindingEnvVars` fields.

[discrete]
=== Examples

When a service binding resource is defined in the Devfile, and the component is not deployed, the output is similar to following:

.Sample command
[source,terminal]
----
$ odo list binding -o json
----

.Sample output
[source,json]
----
{
  "bindingsInDevfile": [
    "my-nodejs-app-cluster-sample"
  ],
  "bindings": [
    {
      "name": "my-nodejs-app-cluster-sample",
      "spec": {
        "application": {
          "kind": "Deployment",
          "name": "my-nodejs-app-app",
          "apiVersion": "apps/v1"
        },
        "services": [
          {
            "kind": "Cluster",
            "name": "cluster-sample",
            "apiVersion": "postgresql.k8s.enterprisedb.io/v1"
          }
        ],
        "detectBindingResources": true,
        "bindAsFiles": true
      }
    }
  ]
}
----

With the same Devfile, when `odo dev` is running, the output is similar to following (note the `.bindings[*].status` field):

.Sample command
[source,terminal]
----
$ odo list binding -o json
----

.Sample output
[source,json]
----
{
  "bindingsInDevfile": [
    "my-nodejs-app-cluster-sample"
  ],
  "bindings": [
    {
      "name": "my-nodejs-app-cluster-sample",
      "spec": {
        "application": {
          "kind": "Deployment",
          "name": "my-nodejs-app-app",
          "apiVersion": "apps/v1"
        },
        "services": [
          {
            "kind": "Cluster",
            "name": "cluster-sample",
            "apiVersion": "postgresql.k8s.enterprisedb.io/v1"
          }
        ],
        "detectBindingResources": true,
        "bindAsFiles": true
      },
      "status": {
        "bindingFiles": [
          "${SERVICE_BINDING_ROOT}/my-nodejs-app-cluster-sample/database",
          "${SERVICE_BINDING_ROOT}/my-nodejs-app-cluster-sample/host",
          "${SERVICE_BINDING_ROOT}/my-nodejs-app-cluster-sample/pgpass",
          "${SERVICE_BINDING_ROOT}/my-nodejs-app-cluster-sample/provider",
          "${SERVICE_BINDING_ROOT}/my-nodejs-app-cluster-sample/type",
          "${SERVICE_BINDING_ROOT}/my-nodejs-app-cluster-sample/username",
          "${SERVICE_BINDING_ROOT}/my-nodejs-app-cluster-sample/ca.crt",
          "${SERVICE_BINDING_ROOT}/my-nodejs-app-cluster-sample/ca.key",
          "${SERVICE_BINDING_ROOT}/my-nodejs-app-cluster-sample/clusterIP",
          "${SERVICE_BINDING_ROOT}/my-nodejs-app-cluster-sample/password",
          "${SERVICE_BINDING_ROOT}/my-nodejs-app-cluster-sample/tls.crt",
          "${SERVICE_BINDING_ROOT}/my-nodejs-app-cluster-sample/tls.key"
        ],
        "runningIn": {
          "dev": true,
          "deploy": false,
        }
      }
    }
  ]
}
----

When `odo dev` is running, if you execute the command from a directory without Devfile,
you get an output similar to the following (note that the `.bindingsInDevfile` field is not present anymore):

.Sample command
[source,terminal]
----
$ odo list binding -o json
----

.Sample output
[source,json]
----
{
  "bindings": [
    {
      "name": "my-nodejs-app-cluster-sample",
      "spec": {
        "application": {
          "kind": "Deployment",
          "name": "my-nodejs-app-app",
          "apiVersion": "apps/v1"
        },
        "services": [
          {
            "kind": "Cluster",
            "name": "cluster-sample",
            "apiVersion": "postgresql.k8s.enterprisedb.io/v1"
          }
        ],
        "detectBindingResources": true,
        "bindAsFiles": true
      },
      "status": {
        "bindingFiles": [
          "${SERVICE_BINDING_ROOT}/my-nodejs-app-cluster-sample/database",
          "${SERVICE_BINDING_ROOT}/my-nodejs-app-cluster-sample/host",
          "${SERVICE_BINDING_ROOT}/my-nodejs-app-cluster-sample/pgpass",
          "${SERVICE_BINDING_ROOT}/my-nodejs-app-cluster-sample/provider",
          "${SERVICE_BINDING_ROOT}/my-nodejs-app-cluster-sample/type",
          "${SERVICE_BINDING_ROOT}/my-nodejs-app-cluster-sample/username",
          "${SERVICE_BINDING_ROOT}/my-nodejs-app-cluster-sample/ca.crt",
          "${SERVICE_BINDING_ROOT}/my-nodejs-app-cluster-sample/ca.key",
          "${SERVICE_BINDING_ROOT}/my-nodejs-app-cluster-sample/clusterIP",
          "${SERVICE_BINDING_ROOT}/my-nodejs-app-cluster-sample/password",
          "${SERVICE_BINDING_ROOT}/my-nodejs-app-cluster-sample/tls.crt",
          "${SERVICE_BINDING_ROOT}/my-nodejs-app-cluster-sample/tls.key"
        ],
        "runningIn": {
          "dev": true,
          "deploy": false
        }
      }
    }
  ]
}
----


== odo describe binding -o json

The `odo describe binding` command lists all the service binding resources declared in the devfile and, if the resource is deployed to the cluster, also displays the variables that can be used from the component.

If a name is given, the command does not extract information from the Devfile, but instead extracts information from the deployed resource with the given name.

If a name is not specified, the output of the command is a list of service binding details, for example:

.Sample command
[source,terminal]
----
$ odo describe binding -o json
----

.Sample output
[source,json]
----
[
  {
    "name": "my-first-binding",
    "spec": {
      "application": {
        "kind": "Deployment",
        "name": "my-nodejs-app-app",
        "apiVersion": "apps/v1"
      },
      "services": [
        {
          "apiVersion": "postgresql.k8s.enterprisedb.io/v1",
          "kind": "Cluster",
          "name": "cluster-sample",
          "namespace": "shared-services-ns"
        }
      ],
      "detectBindingResources": false,
      "bindAsFiles": true,
      "namingStrategy": "lowercase"
    },
    "status": {
      "bindingFiles": [
        "${SERVICE_BINDING_ROOT}/my-first-binding/host",
        "${SERVICE_BINDING_ROOT}/my-first-binding/password",
        "${SERVICE_BINDING_ROOT}/my-first-binding/pgpass",
        "${SERVICE_BINDING_ROOT}/my-first-binding/provider",
        "${SERVICE_BINDING_ROOT}/my-first-binding/type",
        "${SERVICE_BINDING_ROOT}/my-first-binding/username",
        "${SERVICE_BINDING_ROOT}/my-first-binding/database"
      ],
      "bindingEnvVars": [
        "PASSWD"
      ]
    }
  },
  {
    "name": "my-second-binding",
    "spec": {
      "application": {
        "kind": "Deployment",
        "name": "my-nodejs-app-app",
        "apiVersion": "apps/v1"
      },
      "services": [
        {
          "apiVersion": "postgresql.k8s.enterprisedb.io/v1",
          "kind": "Cluster",
          "name": "cluster-sample-2"
        }
      ],
      "detectBindingResources": true,
      "bindAsFiles": true
    },
    "status": {
      "bindingFiles": [
        "${SERVICE_BINDING_ROOT}/my-second-binding/ca.crt",
        "${SERVICE_BINDING_ROOT}/my-second-binding/clusterIP",
        "${SERVICE_BINDING_ROOT}/my-second-binding/database",
        "${SERVICE_BINDING_ROOT}/my-second-binding/host",
        "${SERVICE_BINDING_ROOT}/my-second-binding/ca.key",
        "${SERVICE_BINDING_ROOT}/my-second-binding/password",
        "${SERVICE_BINDING_ROOT}/my-second-binding/pgpass",
        "${SERVICE_BINDING_ROOT}/my-second-binding/provider",
        "${SERVICE_BINDING_ROOT}/my-second-binding/tls.crt",
        "${SERVICE_BINDING_ROOT}/my-second-binding/tls.key",
        "${SERVICE_BINDING_ROOT}/my-second-binding/type",
        "${SERVICE_BINDING_ROOT}/my-second-binding/username"
      ]
    }
  }
]
----

When specifying a name, the output is a unique service binding:

.Sample command
[source,terminal]
----
$ odo describe binding --name my-first-binding -o json
----

.Sample output
[source,json]
----
{
  "name": "my-first-binding",
  "spec": {
      "application": {
        "kind": "Deployment",
        "name": "my-nodejs-app-app",
        "apiVersion": "apps/v1"
      },
    "services": [
      {
        "apiVersion": "postgresql.k8s.enterprisedb.io/v1",
        "kind": "Cluster",
        "name": "cluster-sample",
                "namespace": "shared-services-ns"
      }
    ],
    "detectBindingResources": false,
    "bindAsFiles": true
  },
  "status": {
    "bindingFiles": [
      "${SERVICE_BINDING_ROOT}/my-first-binding/host",
      "${SERVICE_BINDING_ROOT}/my-first-binding/password",
      "${SERVICE_BINDING_ROOT}/my-first-binding/pgpass",
      "${SERVICE_BINDING_ROOT}/my-first-binding/provider",
      "${SERVICE_BINDING_ROOT}/my-first-binding/type",
      "${SERVICE_BINDING_ROOT}/my-first-binding/username",
      "${SERVICE_BINDING_ROOT}/my-first-binding/database"
    ],
    "bindingEnvVars": [
      "PASSWD"
    ]
  }
}
----

== odo preference view -o json

The `odo preference view` command lists all user preferences and all user Devfile registries.

.Sample command
[source,terminal]
----
$ odo preference view -o json
----

.Sample output
[source,json]
----
{
  "preferences": [
    {
      "name": "UpdateNotification",
      "value": null,
      "default": true,
      "type": "bool",
      "description": "Flag to control if an update notification is shown or not (Default: true)"
    },
    {
      "name": "Timeout",
      "value": null,
      "default": 1000000000,
      "type": "int64",
      "description": "Timeout (in Duration) for cluster server connection check (Default: 1s)"
    },
    {
      "name": "PushTimeout",
      "value": null,
      "default": 240000000000,
      "type": "int64",
      "description": "PushTimeout (in Duration) for waiting for a Pod to come up (Default: 4m0s)"
    },
    {
      "name": "RegistryCacheTime",
      "value": null,
      "default": 900000000000,
      "type": "int64",
      "description": "For how long (in Duration) odo will cache information from the Devfile registry (Default: 15m0s)"
    },
    {
      "name": "ConsentTelemetry",
      "value": false,
      "default": false,
      "type": "bool",
      "description": "If true, odo will collect telemetry for the user's odo usage (Default: false)\n\t\t    For more information: https://developers.redhat.com/article/tool-data-collection"
    },
    {
      "name": "Ephemeral",
      "value": null,
      "default": false,
      "type": "bool",
      "description": "If true, odo will create an emptyDir volume to store source code (Default: false)"
    }
  ],
  "registries": [
    {
      "name": "DefaultDevfileRegistry",
      "url": "https://registry.devfile.io",
      "secure": false
    }
  ]
}
----

== odo list services -o json

The `odo list services` command lists all the bindable Operator backed services available in the current project/namespace.

.Sample command
[source,terminal]
----
$ odo list services -o json
----

.Sample output
[source,json]
----
{
  "bindableServices": [
    {
      "name": "cluster-sample",
      "namespace": "myproject",
      "kind": "Cluster",
      "group": "postgresql.k8s.enterprisedb.io",
      "service": "cluster-sample/Cluster.postgresql.k8s.enterprisedb.io"
    }
  ]
}
----

You can also list all the bindable Operator-backed services from a different project or namespace that you have access to:

.Sample command
[source,terminal]
----
$ odo list services -o json -n <project-name>
----

.Sample output
[source,json]
----
{
  "bindableServices": [
    {
      "name": "hello-world",
      "namespace": "newproject",
      "kind": "RabbitmqCluster",
      "group": "rabbitmq.com",
      "service": "hello-world/RabbitmqCluster.rabbitmq.com"
    }
  ]
}
----

Using the `-A` or `--all-namespaces` flag:

.Sample command
[source,terminal]
----
$ odo list services -o json -A
----

.Sample output on success
[source,json]
----
{
  "bindableServices": [
    {
      "name": "cluster-sample",
      "namespace": "myproject",
      "kind": "Cluster",
      "group": "postgresql.k8s.enterprisedb.io",
      "service": "cluster-sample/Cluster.postgresql.k8s.enterprisedb.io"
    },
    {
      "name": "hello-world",
      "namespace": "newproject",
      "kind": "RabbitmqCluster",
      "group": "rabbitmq.com",
      "service": "hello-world/RabbitmqCluster.rabbitmq.com"
    }
  ]
}
----
